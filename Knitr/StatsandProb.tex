\documentclass[12pt, a4paper, oneside]{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt} % Paper size, default font size and one-sided paper
%\graphicspath{{./Figures/}} % Specifies the directory where pictures are stored
%\usepackage[dcucite]{harvard}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{pdflscape}
\usepackage{rotating}
\usepackage[flushleft]{threeparttable}
\usepackage{multirow}
\usepackage[comma, sort&compress]{natbib}% Use the natbib reference package - read up on this to edit the reference style; if you want text (e.g. Smith et al., 2012) for the in-text references (instead of numbers), remove 'numbers' 
\usepackage{graphicx}
%\bibliographystyle{plainnat}
\bibliographystyle{agsm}
\usepackage[colorlinks = true, citecolor = blue, linkcolor = blue]{hyperref}
%\hypersetup{urlcolor=blue, colorlinks=true} % Colors hyperlinks in blue - change to black if annoying
%\renewcommand[\harvardurl]{URL: \url}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
\title{Stats and Probability Information}
\author{Rob Hayward}
\date{\today}
\maketitle
\subsection*{Continuous and marginal distributions}

The marginal distribution of $x$ in a two-variable distribution is equal to the sum of the joint distribution over $y$. 
\begin{equation}
Pr(X = x) = \sum_y Pr(X = x, Y = y) = \sum_y Pr(X = x|Y = y)Pr(Y = y)
\end{equation}

From \href{http://en.wikipedia.org/wiki/Marginal_distribution}{Wikipedia}

For the continuous case
\begin{equation}
p_X(x) = \int_y p_{X,Y}(x,y)dy = \int_y p_{X|Y}(x|y)p_Y(y)dy
\end{equation}

There are three related distributions:  the marginal, the joint and the conditional. 

\subsection{Markov Chain Monte Carlo Methods}
This comes from Dave Miles.  There are four sections. 
\begin{itemize}
\item \href{http://davegiles.blogspot.ca/2014/03/mcmc-for-econometrics-students-i.html}{Introduction}
\item \href{http://davegiles.blogspot.ca/2014/03/mcmc-for-econometrics-students-ii_18.html}{Showing the MCMC works}
\item \href{http://davegiles.blogspot.ca/2014/03/mcmc-for-econometrics-students-iii.html}{Example to extract the marginal posterior distribution}
\item \href{http://davegiles.blogspot.com/2014/03/mcmc-for-econometrics-students-part-iv.html#more}{Use R to implement MCMC}
\end{itemize}

This is an update of the code by \href{http://www.econometricsbysimulation.com/2014/04/dave-giles-on-mcmc-for-econometrics.html}{Economics by Simulation}

The Gibbs sampler exploits the characteristics of the Markov chain.  With two parameters $\theta_1$ and $\theta_2$, $p(\theta_1, \theta_2)$ is the prior pdf and $L(\theta_1, \theta_2 | y) = p(y | \theta_1, \theta_2$ is the likelihood function.  Using Bayes theory, the posterior pdf for the parameters is 
\begin{equation}
p(\theta_1, \theta_2| y) \propto p(\theta_1, \theta_2)L(\theta_1, \theta_2| y)
\end{equation}

There are a numbrer of steps. 
\begin{enumerate}
\item Assign initial values to $\theta_1^{(0)}$ and $\theta_2^{(0)}$
\item Draw a random value $\theta_1^{(1)}$ from $p(\theta_1|\theta_2^{(0)}, y)$
\item The draw a random value $\theta_2^{(1)}$ from $p(\theta_2|\theta_1^{(1)}, y)$
\item Draw a random value $\theta_1^{(2)}$ from $p(\theta_1|\theta_2^{(1)}, y)$
\item Repeat items 3 and 4
\end{enumerate}

We end up a with two series that are Markov chains so the initial values do not matter and after many replications the chains start to behave as if they were random draws from the \emph{marginal} posterior distibution $p(\theta_1 |y)$ and $p(\theta_2|y)$ rather than the \emph{conditional} posterior distribution $p(\theta_1| \theta_2, y)$ $p(\theta_1|\theta_2, y)$.  The early values are part of the \emph{burn in} period and should be discarded.   

Here is a very simple version of the sampler applied to linear regression.  A draw for the slope coefficient is made conditional upon the given intercept and then a new intercept is drawn conditional on the slope.  This is repeated.  I think that they should be random draws from the data.  

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Create a simple MCMC sampler}

x <- \hlkwd{seq}(1, 100, by = 1)
e <- \hlkwd{rnorm}(\hlkwd{length}(x))
y <- 0.5 + 5 * x + e
\hlcom{# prior}
a <- \hlkwd{rep}(NA, times = \hlkwd{length}(x))
b <- \hlkwd{rep}(NA, times = \hlkwd{length}(x))
a[1] = 1
b[1] = 1
\hlkwd{for} (i in 2:100) \{
    b[i] <- (y[i] - a[i - 1] - \hlkwd{rnorm}(1))/x[i]
    a[i] <- y[i] - b[i] * x[i] - \hlkwd{rnorm}(1)
\}
\hlkwd{plot}(y ~ x, type = \hlstr{"p"}, main = \hlstr{"Regression with \hlkwd{OLS} (red) and \hlkwd{MCMC} (blue)"})
\hlkwd{abline}(a = \hlkwd{mean}(a), b = \hlkwd{mean}(b), col = \hlstr{"blue"})
\hlkwd{lines}(\hlkwd{fitted}(\hlkwd{lm}(y ~ x)), col = \hlstr{"red"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/MCMC} 

\end{knitrout}


Once there is a large sample of $p(\theta_1|y)$ and the burn-in have been discarded, the mean, variance, median or mode of the marginal posterior can be calculated.  The process can be expanded to more parameters. 

\subsubsection{Gibbs Sampler}
The Gibbs sampler is a special case of the Metropolis-Hasting algorithm. 
The R code from Dave Giles in the file DaveGilesMCMCcoes.R has better version than this. I am not sure how we got from $\rho = 0.5$ to $sd = 1-\rho^2$. 

This example is based on two random variables $Y_1$ and $Y_2$, with a mean vector of $(\mu_1, \mu_2)$ a correlation of $\rho$, the variances of $Y_1$ and $Y_2$ are $\sigma_1^2$ and $\sigma_2^2$ respectively and the covariance between $Y_1$ and $Y_2$ is $\rho \sigma_1 \sigma_2$. \footnote{As $\rho = \frac{\sigma_{Y_1, Y_2}}{\sigma_1 \sigma_2}$.  Some additional reading on covariance \href{http://www.cogsci.ucsd.edu/~desa/109/trieschmarksslides.pdf}{http://www.cogsci.ucsd.edu/~desa/109/trieschmarksslides.pdf}}



The conditional distribution of $Y_1$ given $Y_2$ is 

\begin{equation}
p(Y_1| Y_2) \sim N \left(\mu_1 + \frac{\rho\sigma_1(Y_2 - \mu_2)}{\sigma_2}, \sigma_1^2(1 - \rho^2)\right)
\end{equation}

and the conditional distribution of $Y_2$ given $Y_1$ is

\begin{equation}
p(Y_2| Y_1) \sim N \left(\mu_2 + \frac{\rho\sigma_2(Y_1 - \mu_1)}{\sigma_2}, \sigma_1^2(1 - \rho^2) \right)
\end{equation}

This can be used to find the marginal distribution. It is known that the marginal distribution for $Y_1$ is
\begin{equation}
p(Y_1) \sim N(\mu_1, \sigma_1^2)
\end{equation}

and for $Y_2$ is 
\begin{equation}
p(Y_2) \sim N(\mu_2, \sigma_2^2)
\end{equation}

However, to test the MCMC draw from the conditional to find the marginal (that we already know).  

Set $\mu_1 = 0$ and $\mu_2 = 0$ and $\sigma_1 = 1$ and $\sigma_2 = 1$

The steps for the Gibbs sampler are 
\begin{enumerate}
\item Chose an initial value for $Y_1$ called $Y_1^{(0)}$
\item Next, generate a random $Y_2$ value ($Y_2^{(0)})$ from $p(Y_2| Y_1^{(0)})$
\item Then, generte a new random $Y_1$ value (say $Y_1^{(1)})$ from $p(Y_1| Y_2^{(0)})$
\item Repeat steps 2 and 3 many times saving the strings of $Y_1$ and $Y_2$ values.
\item Throw away the first thousand or so values as they are draws from the \emph{conditional distribution}
\item Now the values from the marginal distribution of interest
\end{enumerate}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}(123)
nreps <- 105000
nb <- 5000
yy1 <- \hlkwd{array}(, nreps)
yy2 <- \hlkwd{array}(, nreps)
rho <- 0.5
sd <- \hlkwd{sqrt}(1 - rho^2)
y1 <- \hlkwd{rnorm}(1, 0, sd)
\hlkwd{for} (i in 1:nreps) \{
    y2 <- \hlkwd{rnorm}(1, 0, sd) + rho * y1
    y1 <- \hlkwd{rnorm}(1, 0, sd) + rho * y2
    yy1[i] <- y1
    yy2[i] <- y2
\}
nb1 <- nb + 1
yy1b <- yy1[nb1:nreps]
yy2b <- yy2[nb1:nreps]
\hlkwd{plot}(yy1b, col = 2, main = \hlstr{"MCMC for Bivarite Normal"}, xlab = \hlstr{"Repetitions"}, 
    ylab = \hlstr{"Y1"})
\hlkwd{abline}(h = 3, lty = 2)
\hlkwd{abline}(h = -3, lty = 2)
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/MCM} 

\end{knitrout}

The values are centered around zero as they should be. 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}(yy2b, col = 4, main = \hlstr{"MCMC for Bivarite Normal"}, xlab = \hlstr{"Repetitions"}, 
    ylab = \hlstr{"Y2"})
\hlkwd{abline}(h = 3, lty = 2)
\hlkwd{abline}(h = -3, lty = 2)
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/MCMC2} 

\end{knitrout}

The summary statistics are below. 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}(yy1b)
\end{alltt}
\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  -4.400  -0.671   0.008   0.005   0.678   4.450
\end{verbatim}
\begin{alltt}
\hlkwd{var}(yy1b)
\end{alltt}
\begin{verbatim}
## [1] 0.9954
\end{verbatim}
\begin{alltt}
\hlkwd{summary}(yy2b)
\end{alltt}
\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  -4.280  -0.668   0.007   0.007   0.681   4.110
\end{verbatim}
\begin{alltt}
\hlkwd{var}(yy2b)
\end{alltt}
\begin{verbatim}
## [1] 1.004
\end{verbatim}
\end{kframe}
\end{knitrout}

The means are zero and the variances are close  to unity. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hist}(yy1b, prob = T, col = 2, main = \hlstr{"MCMC for Bivariate Normal"}, xlab = \hlstr{"Y1"}, 
    ylab = \hlstr{"Marginal PDF for Y1"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/Hist1} 
\begin{kframe}\begin{alltt}
\hlkwd{hist}(yy2b, prob = T, col = 4, main = \hlstr{"MCMC for Bivariate Normal"}, xlab = \hlstr{"Y2"}, 
    ylab = \hlstr{"Marginal PDF for Y2"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/Hist2} 

\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{qqnorm}(yy1b)
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/Tests1} 
\begin{kframe}\begin{alltt}
\hlkwd{qqnorm}(yy2b)
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/Tests2} 
\begin{kframe}\begin{alltt}
\hlkwd{library}(tseries)
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: there is no package called 'tseries'}}\begin{alltt}
\hlkwd{jarque.bera.test}(yy1b)
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: could not find function "{}jarque.bera.test"{}}}\begin{alltt}
\hlkwd{jarque.bera.test}(yy1b)
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: could not find function "{}jarque.bera.test"{}}}\end{kframe}
\end{knitrout}


\subsection{Mixture Model}
This is a probabilistic model that relates some random variables to some other variables.  The model has sub-populations. The properties of the sub-population are different from those of the parent. The sub-populations may not be observable.  For example, the distribution of returns may be different in different sub-population or regime. 

A \emph{mixture distribution} is the probability distribution of a random variable  whose values are derived from an underlying set of random variables. The \emph{mixture components} are individual distributions with \emph{mixture weights}.  Even in cases where the mixture comonents have a normal distribution, the mixture distribution is likely to be non-normal. Mixture models are used to understand the sub-population when there is only access to the information about the pooled population. 

The mixture model will be comprised of N random varibles distributed according to K components, with each component belonging to the same distribution. The k mixture weights sum to one. Each component will have parameters (mean and variance in the case of normal distribution).  

The method will try to estimate the all the parameters of the model from the data.  The underlying data is known $(x_i)$; the number of mixture components is set $(K)$; the parameters of the distribution of each mixture component $(\theta_{i=1\dots K})$; mixture weight $(\Phi_{i = 1\dots K})$; $\mathbf{\Phi}$ K-dimensional vector summing to 1; $F(x|\theta)$ probability distribution of observations parameterised on $\theta$; $\alpha$ shared hyperparameter for component weights; $\beta$ shared hyperparameter for mixture weights; $H(\theta|\alpha)$ prior probability distribution of component parameters; 


\subsection{Regression}
This is a series of sessions that introduce regression with R.  The first page is \href{http://pingax.com/2013/11/}{here}.  \href{http://pingax.com/linear-regression-with-r-step-by-step-implementation-part-1/}{Linear Regression: Step-by-step}. This is essentially a version of the Andrew Ng Machine Learning Course.  

If $Y$ is the dependent variable, $X_1, X_2, \dots X_n$ are the explanatory variables and $\Theta$ are unknown parameters, regression takes can be carried out in a number of ways. 

\subsubsection{OLS}
\begin{equation}
h_{\Theta}(x) = \Theta_0 + \Theta_1 x
\end{equation}

The aim is to find values of $\Theta$ so that the model will fit the data.  The \emph{cost function} will assess the difference between the predicted and the actual values. One version of the cost function is 
\begin{equation}
J(\Theta_0, \Theta_1) = \frac{1}{2m} \sum_{i=1}^m (h_{\Theta}(X^{(i)} - y^{(i)}))^2
\end{equation}
Change the values of $\Theta$ to minimise the cost. The method used is gradient decent. 

The partital derivative of the cost function with respect to the $\Theta$ are
\begin{subequations}
\begin{equation}
\Theta_0 = \Theta_0 - \alpha \frac{1}{m}\sum_{i=1}^m (h_{\Theta}(x^{(i)}) - y^{(i)})
\end{equation}
\begin{equation}
\Theta_1 = \Theta_1 - \alpha \frac{1}{m}\sum_{i=1}^m (h_{\Theta}(x^{(i)}) - y^{(i)})x^{(i)}
\end{equation}
\end{subequations}

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
data <- \hlkwd{read.csv}(\hlstr{"../Data/Reg.csv"})
y <- data$profit
x <- data$population
\hlkwd{plot}(y ~ x, main = \hlstr{"Profits vs Population"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/Regression} 

\end{knitrout}

The objective of the regression is to minimise the cost function.
\begin{equation}
J(\Theta_0, \Theta_1) = \frac{1}{2m} \sum_{i=1}^m (h_{\Theta}(X^{(i)} - y^{(i)}))^2
\end{equation}
Where the hypothesis is given by 
\begin{equation}
h_{\Theta}(x) = \Theta^Tx = \Theta_0 + \Theta_1x_1
\end{equation}
To take account of the intercept $\Theta_0$ an additional column of constants is added to $x$. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Add ones to x}
x <- \hlkwd{cbind}(1, x)
\hlcom{# Initialise theta vector}
theta <- \hlkwd{c}(0, 0)
\hlcom{# Number of observations}
m <- \hlkwd{nrow}(x)
\hlcom{# Calculate the cost}
cost <- \hlkwd{sum}(((x %*% theta) - y)^2)/(2 * m)
cost
\end{alltt}
\begin{verbatim}
## [1] 32.07
\end{verbatim}
\end{kframe}
\end{knitrout}

The initial value is 32.07 (how do I take this from the chunk?).  Now 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Set learning parameter}
alpha <- 0.001
\hlcom{# Number of iterations}
iterations <- 1500
\hlcom{# updating thetas using gradient update}
\hlkwd{for} (i in 1:iterations) \{
    theta[1] <- theta[1] - alpha * (1/m) * \hlkwd{sum}(((x %*% theta) - y))
    theta[2] <- theta[2] - alpha * (1/m) * \hlkwd{sum}(((x %*% theta) - y) * x[, 2])
\}
\hlcom{# Predict for areas of the 35,000 and 70,000 people}
predict1 <- \hlkwd{c}(1, 3.5) %*% theta
predict2 <- \hlkwd{c}(1, 7) %*% theta
predict1
\end{alltt}
\begin{verbatim}
##       [,1]
## [1,] 2.247
\end{verbatim}
\begin{alltt}
predict2
\end{alltt}
\begin{verbatim}
##       [,1]
## [1,] 5.356
\end{verbatim}
\begin{alltt}
\hlkwd{plot}(data$population ~ data$profit, main = \hlstr{"Profits vs Population"})
\hlkwd{abline}(theta, col = \hlstr{"red"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/Regression3} 

\end{knitrout}

I think it is right, but....Needs to be looked at. 

\subsection{Adjusted R squared}
\href{http://davegiles.blogspot.ca/2013/05/when-will-adjusted-r-squared-increase.html}{Adjusted R squared} applied a penalty to the basic R squard to account for additional variables.  The equartion is 

\begin{equation}
R_A^2 = 1 - \left [ \frac{(n-1)}{(n-k)} \right ] [1 - R^2]
\end{equation}

Adding a regressor to the equation will increase (reduce)) the $R_A^"$ when the absolute value of the t-statistic is greater (less) than one. Adding a group of regressors to the model will reduce (increase) the $R_A^"$ when the absolute value of the F-statistic is greater than one.  

Proof \href{http://davegiles.blogspot.com/2014/04/proof-of-result-about-adjusted.html}{http://davegiles.blogspot.com/2014/04/proof-of-result-about-adjusted.html}

\subsection{Monte Carlo Simulation}
This comes from \href{http://blog.revolutionanalytics.com/2014/04/quantitative-finance-applications-in-r-5.html}{Revoluitionary Analytics}.  The analysis is in annual terms.  

\begin{equation}
\mu \Delta t + \sigma Z \sqrt{\Delta t}
\end{equation}

where $\mu$ is the drift or average annual return, Z is a standard Normal random variable, t is measured in years so for monthly returns $\Delta t$ equals $\frac{1}{12}$.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
n <- 10000
\hlcom{# Fixing the seed gives us a consistent set of simulated returns}
\hlkwd{set.seed}(106)
z <- \hlkwd{rnorm}(n)  \hlcom{# mean = 0 and sd = 1 are defaults}
mu <- 0.1
sd <- 0.15
delta_t <- 0.25
\hlcom{# apply to expression (*) above}
qtr_returns <- mu * delta_t + sd * z * \hlkwd{sqrt}(delta_t)
\hlkwd{hist}(qtr_returns, breaks = 100, col = \hlstr{"green"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/MC} 

\end{knitrout}


Now the descriptive statistics can be uncovered from the simulated results. 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
stats <- \hlkwd{c}(\hlkwd{mean}(qtr_returns) * 4, \hlkwd{sd}(qtr_returns) * 2)  \hlcom{# \hlkwd{sqrt}(4)}
\hlkwd{names}(stats) <- \hlkwd{c}(\hlstr{"mean"}, \hlstr{"volatility"})
stats
\end{alltt}
\begin{verbatim}
##       mean volatility 
##    0.09901    0.14976
\end{verbatim}
\end{kframe}
\end{knitrout}

This is the basic model.  It would also be possible to simulate two variables and to include some relationship between the two in the analysis.  It would also be possible to simulate an asset in two different regimes. A Monte-Carlo Markov Model (MCMM) would require another set of $\mu$ and $\sigma$ inputs as well as a transition matrix of the probabilities that there is a switch from one regime to another. 
 
\subsection{Generalised Lambda Distribution}
This is from \href{http://blog.revolutionanalytics.com/2014/02/quantitative-finance-applications-in-r-4-using-the-generalized-lambda-distribution-to-simulate-market-returns.html}{Revolutionary Analytics}.  The four parameters $\lambda_1$, $\lambda_2$, $\lambda_3$ and $\lambda_4$ indicate the location, scale, skew and kurtosis of the distribution. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{require}(GLDEX)
\hlkwd{require}(quantmod)

\hlkwd{getSymbols}(\hlstr{"SPY"}, from = \hlstr{"1994-02-01"})
\end{alltt}
\begin{verbatim}
## [1] "SPY"
\end{verbatim}
\begin{alltt}
SPY.Close <- SPY[, 4]  \hlcom{# Closing prices}

SPY.vector <- \hlkwd{as.vector}(SPY.Close)

\hlcom{# Calculate log returns}
sp500 <- \hlkwd{diff}(\hlkwd{log}(SPY.vector), lag = 1)
sp500 <- sp500[-1]  \hlcom{# Remove the NA in the first position}
\hlcom{# Set normalise='Y' so that kurtosis is calculated with reference to}
\hlcom{# kurtosis = 0 under Normal distribution}
\hlkwd{fun.moments.r}(sp500, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002664  0.0001528 -0.0969262  9.5433262
\end{verbatim}
\end{kframe}
\end{knitrout}

Now fit the GLD with the function fun.data.fit.mm. There are warnings but these can be ignored. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
spLambdaDist = \hlkwd{fun.data.fit.mm}(sp500)
spLambdaDist
\end{alltt}
\begin{verbatim}
##            RPRS     RMFMKL
## [1,]  3.884e-04  3.244e-04
## [2,] -4.238e+01  2.039e+02
## [3,] -1.677e-01 -1.699e-01
## [4,] -1.641e-01 -1.616e-01
\end{verbatim}
\begin{alltt}
\hlkwd{fun.plot.fit}(fit.obj = spLambdaDist, data = sp500, nclass = 100, param = \hlkwd{c}(\hlstr{"rs"}, 
    \hlstr{"fmkl"}), xlab = \hlstr{"Returns"})
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/GLD} 

\end{knitrout}

Now it is possible to generrate simualted results using the function rgl(). Lambdas need to be identified. 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
lambda_params_rs <- spLambdaDist[, 1]
lambda1_rs <- lambda_params_rs[1]
lambda2_rs <- lambda_params_rs[2]
lambda3_rs <- lambda_params_rs[3]
lambda4_rs <- lambda_params_rs[4]

lambda_params_fmkl <- spLambdaDist[, 2]
lambda1_fmkl <- lambda_params_fmkl[1]
lambda2_fmkl <- lambda_params_fmkl[2]
lambda3_fmkl <- lambda_params_fmkl[3]
lambda4_fmkl <- lambda_params_fmkl[4]
\end{alltt}
\end{kframe}
\end{knitrout}

Now generate simulations of each variety. 

There are problems with the rgl function.  I am not sure what this does.  It is 10 million simulations.  I think that the rgl just uses extra hardware to make the change. It may be useful to re-do this last section using a different method. 
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{require}(gld)
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: gld}}\begin{alltt}
\hlkwd{require}(GLDEX)
\end{alltt}


{\ttfamily\noindent\itshape\color{messagecolor}{\#\# Loading required package: GLDEX\\\#\# Loading required package: cluster}}\begin{alltt}
\hlcom{# RS version:}
\hlkwd{set.seed}(100)  \hlcom{# Set seed to obtain a reproducible set}
rs_sample <- \hlkwd{rgl}(n = 1e+07, lambda1 = lambda1_rs, lambda2 = lambda2_rs, lambda3 = lambda3_rs, 
    lambda4 = lambda4_rs, param = \hlstr{"rs"})

\hlcom{# Moments of simulated returns using RS method:}
\hlkwd{fun.moments.r}(rs_sample, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  2.664e-04  9.759e-05 -1.052e-01  9.987e+00
\end{verbatim}
\begin{alltt}

\hlcom{# Moments calculated from market data:}
\hlkwd{fun.moments.r}(sp500, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002664  0.0001528 -0.0969262  9.5433262
\end{verbatim}
\begin{alltt}

\hlcom{# FKML version:}
\hlkwd{set.seed}(100)  \hlcom{# Set seed to obtain a reproducible set}
fmkl_sample <- \hlkwd{rgl}(n = 1e+05, lambda1 = lambda1_fmkl, lambda2 = lambda2_fmkl, 
    lambda3 = lambda3_fmkl, lambda4 = lambda4_fmkl, param = \hlstr{"fmkl"})

\hlcom{# Moments of simulated returns using FMKL method:}
\hlkwd{fun.moments.r}(fmkl_sample, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002434  0.0001542 -0.0870419  8.6061100
\end{verbatim}
\begin{alltt}

\hlcom{# Moments calculated from market data:}
\hlkwd{fun.moments.r}(sp500, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002664  0.0001528 -0.0969262  9.5433262
\end{verbatim}
\end{kframe}
\end{knitrout}

Compare the moments to the S\&P500 market data
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{fun.moments.r}(rs_sample, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  2.664e-04  9.759e-05 -1.052e-01  9.987e+00
\end{verbatim}
\begin{alltt}
\hlkwd{fun.moments.r}(sp500, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002664  0.0001528 -0.0969262  9.5433262
\end{verbatim}
\begin{alltt}
\hlkwd{fun.moments.r}(fmkl_sample, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002434  0.0001542 -0.0870419  8.6061100
\end{verbatim}
\begin{alltt}
\hlkwd{fun.moments.r}(sp500, normalise = \hlstr{"Y"})
\end{alltt}
\begin{verbatim}
##       mean   variance   skewness   kurtosis 
##  0.0002664  0.0001528 -0.0969262  9.5433262
\end{verbatim}
\end{kframe}
\end{knitrout}

\subsection{Lasso method}
\href{http://www.mathtube.org/lecture/video/lasso-brief-review-and-new-significance-test#.U1aODV1sp94.twitter}{Rob Tibshirani}Cancer example that requires identification of appropriate cell. There are 20 cases that are being used as a training set.  Train a classifier to identify whether the cells are cencerous or not.  There are 11,000 features. It would be useful to use as few of the features as possible. Therefore, also want to know which features are important for the classification. 

Sparcity means that the features are reduced by only using those that pass a particular level of significance.  \href{http://statweb.stanford.edu/~tibs/lasso.html}{More here.}

\subsection{Standard Error of the estimated mean}
The standard error of the estimate of the mean is 
\begin{equation}
SD_x = \frac{\sigma}{\sqrt{n}}
\end{equation}
This can be derived from the variance of the sum of independent random variables
\begin{itemize}
\item If $X_1, X_2, \dots, X_n$ are independent observations from a population with a mean $\mu$ and a standard deviation $\sigma$, 
\item Variance of the Total = $T = (X_1, X_2, \dots, X_n)$ is $n\sigma^2$
\item $T/n$ is the mean $\bar{x}$
\item the variance of $T/n$ is $\frac{1}{n^2}n\sigma^2 = \frac{\sigma^2}{n}$
\item \href{https://onlinecourses.science.psu.edu/stat414/node/167}{Explained}
\item the standard deviation of $T/n$ must be $\frac{n}{\sqrt{n}}$
\end{itemize}

\subsection{Logistic Regression}
This comes from \href{http://www.win-vector.com/blog/2010/11/learn-a-powerful-machine-learning-tool-logistic-regression-and-beyond/}{Wim-Vector - logistic regression}.  

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
CarData <- \hlkwd{read.table}(\hlkwd{url}(\hlstr{"http://archive.ics.uci.edu/ml/machine-learning-databases/car/car.data"}), 
    sep = \hlstr{","}, col.names = \hlkwd{c}(\hlstr{"buying"}, \hlstr{"maintenance"}, \hlstr{"doors"}, \hlstr{"persons"}, \hlstr{"lug_boot"}, 
        \hlstr{"safety"}, \hlstr{"rating"}))
logisticModel <- \hlkwd{glm}(rating != \hlstr{"unacc"} ~ buying + maintenance + doors + persons + 
    lug_boot + safety, family = \hlkwd{binomial}(link = \hlstr{"logit"}), data = CarData)
\end{alltt}


{\ttfamily\noindent\color{warningcolor}{\#\# Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred}}\begin{alltt}
\hlkwd{summary}(logisticModel)
\end{alltt}
\begin{verbatim}
## 
## Call:
## glm(formula = rating != "unacc" ~ buying + maintenance + doors + 
##     persons + lug_boot + safety, family = binomial(link = "logit"), 
##     data = CarData)
## 
## Deviance Residuals: 
##    Min      1Q  Median      3Q     Max  
## -3.216   0.000   0.000   0.026   2.434  
## 
## Coefficients:
##                  Estimate Std. Error z value Pr(>|z|)    
## (Intercept)       -28.426   1257.526   -0.02     0.98    
## buyinglow           5.048      0.567    8.90  < 2e-16 ***
## buyingmed           3.922      0.484    8.10  5.5e-16 ***
## buyingvhigh        -2.066      0.375   -5.51  3.5e-08 ***
## maintenancelow      3.406      0.469    7.26  3.9e-13 ***
## maintenancemed      3.406      0.469    7.26  3.9e-13 ***
## maintenancevhigh   -2.825      0.415   -6.82  9.4e-12 ***
## doors3              1.856      0.404    4.59  4.4e-06 ***
## doors4              2.482      0.428    5.80  6.6e-09 ***
## doors5more          2.482      0.428    5.80  6.6e-09 ***
## persons4           29.965   1257.526    0.02     0.98    
## personsmore        29.584   1257.526    0.02     0.98    
## lug_bootmed        -1.517      0.376   -4.04  5.4e-05 ***
## lug_bootsmall      -4.448      0.475   -9.36  < 2e-16 ***
## safetylow         -30.505   1300.343   -0.02     0.98    
## safetymed          -3.004      0.358   -8.40  < 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 2110.47  on 1727  degrees of freedom
## Residual deviance:  339.36  on 1712  degrees of freedom
## AIC: 371.4
## 
## Number of Fisher Scoring iterations: 21
\end{verbatim}
\end{kframe}
\end{knitrout}

The variable levels and values are joined together. The model will provide an estimate of the effect of each category on the rating.  The values for each category are adde together to get the overall rating score. 

The error results of the model can be examined. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{table}(CarData$rating, \hlkwd{predict}(logisticModel, type = \hlstr{"response"}) >= 0.5)
\end{alltt}
\begin{verbatim}
##        
##         FALSE TRUE
##   acc      32  352
##   good      0   69
##   unacc  1166   44
##   vgood     0   65
\end{verbatim}
\end{kframe}
\end{knitrout}


To be completed. 

\subsection{F-Tests}
This is an example that is based on testing for fabricated evidence.  The full documentation is \href{http://errorstatistics.com/2014/05/10/who-ya-gonna-call-for-statistical-fraudbusting-r-a-fisher-p-values-and-error-statistics-again/}{Deborah Mayo}.  As the paper says
\begin{quotation}
``In each experiment, participants (undergraduate students) were randomly assigned to three groups, and each group was given a different ‘intervention’. All participants were then tested on some outcome measure.``
\end{quotation}
The accusation is that the results are \textbf{too} linear.  The relationships are too perfect compared to other studies.  The method used to asses this is called \emph{delta-F}.  The odds of seeing such linear trends are calculated based on the assumption that the trend is linear.  

Unless there is a huge sample, the probability of obtaining a linear trend is very low becuase there is noise. THe amount of noise is evident in the \emph{within group variance}.  For a given sample size and a given level of within group variance, the odds of obtaining a linear trend are calculated as the sum of squares accounted for by a linear model and a none-linear model (one-way ANOVA) divided by the mean-square error (within group variance).

\begin{equation}
\Delta F = \frac{SS_{REG} - SS_B}{MS_W}
\end{equation}

There is one degree of freedom in the numerator and $3(n-1)$ degrees of freedom in the denominator. 

If the difference between the two models (linear and non-linear) is small, it means that there is an underlying linear relationship. Assuming that the relationship is linear, this delta-F metric should follow an F distribution. 

This is more or less the same method that is used to test whether a simple model fits the data as well as a complex model. In that case, the null hypothesis is that the simple model is the correct version and the objective is to determine if the difference between the two is unlikely given the null. 

From the paper

\begin{quotation}
```But here the whole thing is turned on its head. Random noise means that a complex model will sometimes fit the data better than a simple one, even if the simple model describes reality. In a conventional use of F-tests, that would be regarded as a false positive. But in this case it’s the absence of those false positives that’s unusual.```
\end{quotation}

\end{document}
